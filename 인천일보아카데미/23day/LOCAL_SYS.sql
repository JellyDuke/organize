--계정 생성
--CREATE user 아이디 identified by 비밀번호;
ALTER SESSION SET "_ORACLE_SCRIPT" = TRUE; -- 공통 사용자 규칙 해제
CREATE USER PJH_TEST IDENTIFIED BY "1111"; -- 전송(F9)
--권한 부여
--GRANT CREATE SESSION TO 아이디; <-접속권한.
GRANT CREATE SESSION TO PJH_TEST; 
--권한 회수
--REVOKE CREATE SESSION FROM 아이디; <-회수.
REVOKE CREATE SESSION FROM PJH_TEST;
--계정 삭제 
--DROP USER 아이디;
DROP USER PJH_TEST;

--CRUD
--CREATE - INSERT 
--READ - SELECT
--UPDATE - UPDATE
--DELETE - DELETE

--DBA 계정생성
CREATE USER PJH_DBA 
IDENTIFIED BY "1111";
--DBA 권한 부여 (dba의 모든 권한)
GRANT DBA TO PJH_DBA;

--테이블 생성
CREATE TABLE MEMBERS( --회원정보 테이블
    MID NVARCHAR2(5), --아이디 저장, 문자 최대 5글자까지
    MPW NVARCHAR2(5), --비밀번호
    MNAME NVARCHAR2(5)
);
DESC MEMBERS; --테이블 구조 확인
SELECT * FROM members;
INSERT INTO members VALUES('ID01','PW01','회원01');
INSERT INTO members VALUES('ID02','PW02','회원02');
INSERT INTO members VALUES('ID03','PW03','회원03');
SELECT * FROM members;

-- 테이블 생성 
-- CREATE TABLE 테이블이름(
-- 컬럼명1 데이터타입,
-- 컬럼명2 데이터타입,
-- 컬럼명n 데이터타입
-- );

--Table 테이블이름이(가) 생성되었습니다.

CREATE TABLE TESTTBL(
    COL01 CHAR(5),
    COL02 VARCHAR(10)
);
/* 데이터타입
문자형 - 고정형: CHAR(5) (N은 글자의 숫자를 붙이지 않으면 크기를 의미한다.) 5바이트 저장
        가변형: [NVARCHAR2(10 10글자를 저장)] 1바이트를 저장
숫자형 - [NUMBER(글자 자리수)] <- 아무것도 안쓰면 모든걸 저장,
        NUMBER(3), NUMBER(3 최대 3자리수 ,2 소수점 2자리수)
날짜형 - [DATE] // 연-월-일  시:분:초    ,순서
            YYYY-MM-DD HH24:MI:SS
*/


CREATE TABLE CHARTEST_TBL(
    CHARCOL1 CHAR(5), --5BYTE
    NCHARCOL2 NCHAR(5) --5글자
);
--INSERT문
--INSERT INTO 테이블명(컬럼명1,컬럼명2)
--VALUES(데이터1,데이터2);


INSERT INTO CHARTEST_TBL(CHARCOL1, NCHARCOL2)
VALUES('ABCDE','ABCDE');
SELECT *
FROM chartest_tbl;

INSERT INTO CHARTEST_TBL(CHARCOL1, NCHARCOL2)
VALUES('가나다라마','ABCDE'); --오류 열에 대한 값이 너무 큼(실제: 15, 최대값: 5) 한글은 3바이트씩 사용

INSERT INTO CHARTEST_TBL(CHARCOL1, NCHARCOL2)
VALUES('ABCDE','가나다라마');

CREATE TABLE NUMBERTEST_TBL(
    COL1 NUMBER,
    COL2 NUMBER(3),
    COL3 NUMBER(3,2)
);

INSERT INTO NUMBERTEST_TBL
VALUES(123, 123, 1.23);
SELECT * FROM NUMBERTEST_TBL;

INSERT INTO NUMBERTEST_TBL
VALUES(12345678, 123, 1.23); --성공

INSERT INTO NUMBERTEST_TBL
VALUES(123567, 12345, 1.23); --  이 열에 대해 지정된 전체 자릿수보다 큰 값이 허용됩니다.

INSERT INTO NUMBERTEST_TBL
VALUES(123567, 123, 1.23456789); -- 실행성공하지만 저장은 1.23까지 됨

INSERT INTO NUMBERTEST_TBL1111
VALUES(123567, 123, 12.3); -- 이 열에 대해 지정된 전체 자릿수보다 큰 값이 허용됩니다.

--날짜형 데이터
CREATE TABLE DATETEST_TBL(
    COL1 DATE
);
--시스템 DATE 입력
INSERT INTO DATETEST_TBL VALUES(SYSDATE);
SELECT *
FROM DATETEST_TBL;

INSERT INTO DATETEST_TBL VALUES('2023/05/19');
INSERT INTO DATETEST_TBL VALUES('2023-07-19');
SELECT * FROM DATETEST_TBL;
INSERT INTO DATETEST_TBL VALUES('2023/05/19 23:50:48');
INSERT INTO DATETEST_TBL VALUES('202305191159');
--TO_DATE('날짜로 변경할 문자','날짜확인방식'):문자형>> 날짜형으로 변환
INSERT INTO DATETEST_TBL
VALUES( TO_DATE('2023-07-19 23:50:48', 'YYYY-MM-DD HH24:MI:SS'));

--TO_CHAR('문자로 변경할 날짜', '변경할 범위');
SELECT TO_CHAR(COL1, 'YYYY/MM/DD')
FROM DATETEST_TBL;

--테이블변경
--ALTER TABLE 테이블이름
--[ADD,RENAME,MODIFY,DROP]

--새로운 컬럼 추가
--ALTER TABLE 테이블이름
--ADD 컬럼명 데이터타입
CREATE TABLE ALTER_TBL(
    COL1 NUMBER
);
--ALTER_TBL 테이블에 컬럼이름은 NAME, 데이터타입은 NVARCHAR2(5) 컬럼 추가
ALTER TABLE ALTER_TBL
ADD NAME NVARCHAR2(5);
--컬럼 이름 변경
--ALTER TABLE 테이블이름
--RENAME COLUMN 현재컬럼명 TO 바꿀컬럼명
--ALTER_TBL 테이블에 COL1 컬럼명을 AGE로 변경
ALTER TABLE ALTER_TBL
RENAME COLUMN COL1 TO AGE;
DESC ALTER_TBL; --테이블 구조확인
--컬럼의 데이터 타입 변경
--ALTER TABLE 테이블 이름
--MODIFY 컬럼명 데이터타입;
-- ALTER_TBL 테이블에 EMAIL NUMBER 컬럼을 추가
-- ALTER_TBL 테이블의 EMAIL 컬럼의 데이터타입을 문자형 최대 20글자까지
ALTER TABLE ALTER_TBL
ADD EMAIL NUMBER;

ALTER TABLE ALTER_TBL
ADD EMAIL NVARCHAR2(20);

--컬럼 삭제
--ALTER TABLE 테이블이름
--DROP COLUMN 컬럼명;

--ALTER_TBL 테이블의 AGE 컬럼을 삭제
ALTER TABLE ALTER_TBL
DROP COLUMN AGE;
DESC ALTER_TBL;

--제약조건
-- PRIMARY KEY
-- FOREIGN KEY
-- UNIQUE 
-- NOT NULL
-- CHECK
-- DEFAULT

-- UNIQUE : 테이블의 특정한 컬럼 부여 중복되는 값이 입력되지 않도록 방지
DROP TABLE MEMBERS;
CREATE TABLE MEMBERS(
    MID NVARCHAR2(20), --아이디
    MPW NVARCHAR2(20), --비밀번호
    MNAME NVARCHAR2(5),--이름
    MEMAIL NVARCHAR2(20)--이메일
);
--회원정보 입력
INSERT INTO MEMBERS(MID, MPW, MNAME, MEMAIL)
VALUES('PJH','1111','박주호','wnghqkr@naver.com'); --아래 195부터 실행 이후 입력성공
INSERT INTO MEMBERS(MID, MPW, MNAME, MEMAIL)
VALUES('PJH','1111','인천일보','wnghqkr@naver.com'); -- 195행 이후 실행 실패. 무결성 제약 조건(PJH_DBA.UK_MEM_MID)에 위배됩니다
select * from MEMBERS;

--테이블에 제약조건 부여
--ALTER TABLE 테이블이름
--ADD CONSTRAINT 식별이름 제약조건종류 (부여할컬럼명);

--MEMBERS 테이블의 MID 컬럼에 UNIQUE 제약조건 부여
ALTER TABLE MEMBERS
ADD CONSTRAINT UK_MEM_MID UNIQUE (MID); --중복 데이터가 존재해서 오류 발생
DELETE FROM MEMBERS; --데이터 삭제 MEMBERS 테이블로부터 

ALTER TABLE MEMBERS
ADD CONSTRAINT UK_MEM_MID UNIQUE (MID);

INSERT INTO MEMBERS(MID, MPW, MNAME, MEMAIL)
VALUES('PJH','1111','박주호','wnghqkr@naver.com'); --아래 195부터 실행 이후 입력성공
INSERT INTO MEMBERS(MID, MPW, MNAME, MEMAIL)
VALUES('PJH','1111','인천일보','wnghqkr@naver.com'); -- 195행 이후 실행 실패. 무결성 제약 조건(PJH_DBA.UK_MEM_MID)에 위배됩니다.

--MEMBERS 테이블의 MEMAIL 컬럼에 UNIQUE 제약조건 부여
ALTER TABLE MEMBERS
ADD CONSTRAINT UK_MEM_MID UNIQUE(MEMAIL);
INSERT INTO MEMBERS(MID, MPW, MNAME, MEMAIL)
VALUES('PJH','1111','인천일보','wnghqkr@naver.com');

--=================================5.22==========================================
--제약조건
CREATE TABLE MEMBERS1(
    MID1 NVARCHAR2(20),  --아이디
    MPW1 NVARCHAR2(20),  --비밀번호
    MNAME1 NVARCHAR2(5), --이름
    MEMAIL1 NVARCHAR2(20)--이메일
);
--제약 조건 부여(MID 컬럼에 UNIQUE)
ALTER TABLE MEMBERS1
ADD CONSTRAINT UK_MEM1_MID UNIQUE(MID);

--제약조건 부여 - 테이블을 생성하면서 제약조건 부여 1
CREATE TABLE MEMBERS2(
    MID2 NVARCHAR2(20) CONSTRAINT UK_MEM2_MID UNIQUE,  --아이디
    MPW2 NVARCHAR2(20),  --비밀번호
    MNAME2 NVARCHAR2(5), --이름
    MEMAIL2 NVARCHAR2(20)--이메일
);
--제약조건 부여 - 테이블을 생성하면서 제약조건 부여 2
CREATE TABLE MEMBERS3(
    MID NVARCHAR2(20),  --아이디
    MPW NVARCHAR2(20),  --비밀번호
    MNAME NVARCHAR2(5), --이름
    MEMAIL NVARCHAR2(20),--이메일
    CONSTRAINT UK_MEM3_MID UNIQUE(MID)
);
-- UNIQUE : 테이블의 특정한 컬럼 부여 중복되는 값이 입력되지 않도록 방지
INSERT INTO MEMBERS3(MID, MPW, MNAME, MEMAIL)
VALUES('PJH', '1111', '박주호','WNGHQKR@NAVER'); --F9실행
INSERT INTO MEMBERS3(MID, MPW, MNAME, MEMAIL)
VALUES('PJH', '1234', '박주호','abc@NAVER'); --F9실행

--MID 컬럼에 NULL값 입력
INSERT INTO MEMBERS3(MID, MPW, MNAME, MEMAIL)
VALUES(NULL, '1234', '박주호','WNGH-QKR@NAVER'); --F9실행
INSERT INTO MEMBERS3(MPW, MNAME, MEMAIL)
VALUES('111-1', '박-주호','WNGH-QKR@NAVER'); --F9실행
SELECT * FROM MEMBERS3;

--NOT NULL: 지정된 컬럼에 NULL 값을 허용하지 않는다.
--따로 제약을 두지 않으면 기본값으로 NULL을 허용
DROP TABLE MEMBERS;
CREATE TABLE MEMBERS(
    MID NVARCHAR2(20) CONSTRAINT NN_MEM_MID NOT NULL,--그냥 NOT NULL 써도 됨
    MPW NVARCHAR2(20),  --비밀번호
    MNAME NVARCHAR2(5), --이름
    MEMAIL NVARCHAR2(20),--이메일
    CONSTRAINT UK_MEM_MID UNIQUE(MID)
);
INSERT INTO MEMBERS(MID ,MPW, MNAME, MEMAIL)
VALUES(NULL, '1234', '박주호','WNGHQKR@NAVER');
--ORA-01400: NULL을 ("SYS"."MEMBERS"."MID") 안에 삽입할 수 없습니다
CREATE TABLE MEMBERS(
    MID NVARCHAR2(20),  --아이디
    MPW NVARCHAR2(20),  --비밀번호
    MNAME NVARCHAR2(5), --이름
    MEMAIL NVARCHAR2(20),--이메일
    CONSTRAINT UK_MEM_MID UNIQUE(MID)
);
ALTER TABLE MEMBERS
MODIFY MID NOT NULL; --NOT NULL은 수정 MODIFY로 사용
DESC MEMBERS;

ALTER TABLE MEMBERS --제약조건을 지우기 UNIQUE
DROP CONSTRAINT UK_MEM_MID;

ALTER TABLE MEMBERS
MODIFY MID NULL; --NOT NULL 을 NULL로 수정하여 기본값으로 변경(수정)

--제약조건
--  UNIQUE: 테이블의 특정한 컬럼 부여, 중복되는 값이 입력되지 않도록 방지
--  NOT NULL: 특정 컬럼에 NULL값이 입력되지 않도록 방지
--  PRIMARY KEY: UNIQUE + NOT NULL
--               테이블에서 레코드를 구분 지을 수 있는 유일한 컬럼에 부여            

DROP TABLE MEMBERS;
CREATE TABLE MEMBERS(
    MID NVARCHAR2(20),  --아이디
    MPW NVARCHAR2(20),  --비밀번호
    MNAME NVARCHAR2(5), --이름
    MEMAIL NVARCHAR2(20)--이메일
);
-- MID 컬럼에 PRIMARY KEY 부여
ALTER TABLE MEMBERS
ADD CONSTRAINT PK_MEM_MID PRIMARY KEY(MID);
INSERT INTO MEMBERS(MID, MPW, MNAME, MEMAIL)
VALUES( 'PJH','1111','박주호','WNGHQKR@NAVER.COM');

INSERT INTO MEMBERS(MID, MPW, MNAME, MEMAIL)
VALUES( 'PJH','1234','1234','1234'); --UNIQUE 확인

INSERT INTO MEMBERS(MID, MPW, MNAME, MEMAIL)
VALUES( NULL,'1111','박주호','WNGHQKR@NAVER.COM'); --NOT NULL 확인

--이메일 컬럼에 UNIQUE 제약 조건 부여
ALTER TABLE MEMBERS
ADD CONSTRAINT UK_MEM_MID UNIQUE(MEMALL);

INSERT INTO MEMBERS(MID, MPW, MNAME, MEMAIL)
VALUES( '01','1111','박주호',NULL);

INSERT INTO MEMBERS(MID, MPW, MNAME, MEMAIL)
VALUES( '02','1111','박주호',NULL);

-- MNAME 에 PRIMERY KEY 부여
ALTER TABLE MEMBERS
ADD CONSTRAINT PK_MEM_MID PRIMARY KEY(MNAME); --기본키는 한테이블만 가능
ALTER TABLE MEMBERS
ADD CONSTRAINT UK_MEM_MID UNIQUE(MNAME);
SELECT * FROM MEMBERS;

-- DEFAULT: 특정한 컬럼에 값이 입력되지 않을 경우 기본으로 입력되는 값을 설정
DROP TABLE MEMBERS;
CREATE TABLE MEMBERS(
    MID NVARCHAR2(20),  --아이디
    MPW NVARCHAR2(20),  --비밀번호
    MNAME NVARCHAR2(20) DEFAULT '이름없음',--이름
    MAGE NUMBER         --나이
);
-- 나이 컬럼에 기본값 1 설정
ALTER TABLE MEMBERS
MODIFY MAGE DEFAULT 1; --수정

INSERT INTO MEMBERS(MID,MPW,MAGE)
VALUES( '01','1234',10);
INSERT INTO MEMBERS(MID, MAGE)
VALUES( '01',10);
SELECT * FROM MEMBERS;
INSERT INTO MEMBERS(MID, MPW, MNAME, MAGE)
VALUES( '02','1111',DEFAULT,20);


--CHECK : 특정한 컬럼에 입력할 수 있는 값에 대한 조건 부여
DROP TABLE MEMBERS;
CREATE TABLE MEMBERS(
    MID NVARCHAR2(20),  --아이디
    MPW NVARCHAR2(20),  --비밀번호
    MNAME NVARCHAR2(20),--이름
    MAGE NUMBER         --나이
    CONSTRAINT CK_MEM_MAGE CHECK(MAGE > 10)
);
INSERT INTO MEMBERS(MAGE)
VALUES(30); --1 행이 삽입되었습니다.
SELECT * FROM MEMBERS;
INSERT INTO MEMBERS(MAGE)
VALUES(5); -- 체크 제약조건(SYS.CK_MEM_MAGE)이 위배되었습니다

--제약조건
-- PRIMARY KEY
-- FOREIGN KEY
-- UNIQUE 
-- NOT NULL
-- CHECK
-- DEFAULT
DROP TABLE MEMBERS;
CREATE TABLE MEMBERS(
    MID NVARCHAR2(20),  --아이디
    MPW NVARCHAR2(20)   --비밀번호
);
--MID 컬럼에 PRIMARY KEY 부여
ALTER TABLE MEMBERS
ADD CONSTRAINT PK_MEM_MID PRIMARY KEY(MID);
INSERT INTO MEMBERS(MID, MPW) --회원 정보 입력
VALUES('Y','1111');
INSERT INTO MEMBERS(MID, MPW) --회원 정보 입력
VALUES('ABC','1111');
SELECT * FROM MEMBERS;

DROP TABLE LOGINCHECK;
CREATE TABLE LOGINCHECK( --회원의 로그인 시간
    MID NVARCHAR2(20),   --회원 아이디 -MEMBERS 테이블의 MID
    LOGINTIME DATE       --로그인 시간
);

-- LOGINCHECK 테이블에 MID 컬럼에 FOREIGN KEY 지정
ALTER TABLE LOGINCHECK
ADD CONSTRAINT FK_LOG_MID FOREIGN KEY(MID)
REFERENCES MEMBERS(MID);


INSERT INTO LOGINCHECK(MID, LOGINTIME)
VALUES('PJH',SYSDATE); --무결성 제약조건(SYS.FK_LOG_MID)이 위배되었습니다- 부모 키가 없습니다

INSERT INTO LOGINCHECK(MID, LOGINTIME)
VALUES('Y',SYSDATE);   --MEMBERS에 있는 아이디는 가능

INSERT INTO LOGINCHECK(MID, LOGINTIME)
VALUES('ABC',SYSDATE); --MEMBERS에 있는 아이디는 가능

SELECT * FROM LOGINCHECK;

--========================5.23============================
--FOREING KEY: 외래키
--상품정보 테이블 - GOODS
--상품이름 - GNAME 문자타입 20글자까지, PRIMARY KEY로 지정
--상품가격 - GPRICE 숫자타입
--상품브랜드 - GBRAND 문자타입 20글자까지 - NOT NULL

CREATE TABLE GOODS(
    GNAME NVARCHAR2(20) ,  --상품이름
    GPRICE NUMBER,  --상품가격
    GBRAND NVARCHAR2(20)  --상품브랜드
);
--제약 조건 부여
ALTER TABLE GOODS
ADD CONSTRAINT PK_GOODS_GNAME PRIMARY KEY(GNAME)
MODIFY GBRAND NOT NULL;
-- 상품 정보 입력

INSERT INTO GOODS(GNAME, GPRICE, GBRAND) 
VALUES('르네상스','5000000','시대');
INSERT INTO GOODS(GNAME, GPRICE, GBRAND) 
VALUES('혁명','5000000','농민');
INSERT INTO GOODS(GNAME, GPRICE, GBRAND) 
VALUES('아틀란티스','5000000','바다');


--주문내역의 테이블 - ORDERLIST
--상품이름, 가격, 구매자, 주문일시, 배송지, 주문수량
CREATE TABLE ORDERLIST(
    GNAME NVARCHAR2(20),    --상품이름
    GPRICE NUMBER,          --상품가격
    CUSTOMER NVARCHAR2(10), --고객
    ODDATE DATE ,           --주문일자
    ADDRESS NVARCHAR2(50),  --배송지
    QTY NUMBER              --주문수
);
--FOREIGN KEY (외래키) 지정
ALTER TABLE ORDERLIST
ADD CONSTRAINT FK_ODLIST_GNAME FOREIGN KEY(GNAME)
REFERENCES GOODS(GNAME);
--주문 정보 입력
INSERT INTO ORDERLIST(GNAME, GPRICE, CUSTOMER, ODDATE,ADDRESS,QTY)
VALUES('르네상스','5000000','박주호',SYSDATE,'인천',1); --입력가능
INSERT INTO ORDERLIST(GNAME, GPRICE, CUSTOMER, ODDATE,ADDRESS,QTY)
VALUES('혁명','5000000','박주호',SYSDATE,'인천',2);
INSERT INTO ORDERLIST(GNAME, GPRICE, CUSTOMER, ODDATE,ADDRESS,QTY)
VALUES('아틀란티스','5000000','박주호',SYSDATE,'인천',3);
INSERT INTO ORDERLIST(GNAME, GPRICE, CUSTOMER, ODDATE,ADDRESS,QTY)
VALUES('르네상스','5000000','박주호',SYSDATE,'인천',4);
SELECT * FROM ORDERLIST;

INSERT INTO ORDERLIST(GNAME, GPRICE, CUSTOMER, ODDATE,ADDRESS,QTY)
VALUES('사이다','5000000','박주호',SYSDATE,'인천',1); --입력불가능
--무결성 제약조건(SYS.FK_ODLIST_GNAME)이 위배되었습니다- 부모 키가 없습니다

/*
CREATE - INSERT: 데이터 입력
READ   - SELECT: 데이터 조회
UPDATE - UPDATE: 데이터 수정
DELETE - DELETE: 데이터 삭제
*/

--INSERT문
--INSERT INTO 테이블이름(컬럼명1, 컬럼명2, .... 컬럼명N)
--VALUES(컬럼1에 저장할 값, 컬럼2에 저장할 값, .....);
DROP TABLE ORDERLIST;
DROP TABLE GOODS;
CREATE TABLE GOODS(
    GNAME NVARCHAR2(20) ,  --상품이름
    GPRICE NUMBER,  --상품가격
    GBRAND NVARCHAR2(20)  --상품브랜드
);
INSERT INTO GOODS(GNAME,GPRICE,GBRAND)
VALUES('상품명1',10000,'브랜드1');
INSERT INTO GOODS(GBRAND,GNAME)
VALUES('브랜드2','상품명2');
INSERT INTO GOODS(GBRAND)
VALUES('브랜드2');
--컬럼명을 명시하지 않을시 VALUES 항목은 테이블의 모든 컬럼 값
INSERT INTO GOODS
VALUES('브랜드2'); -- GNAME, GPRICE, GBRAND 맞춰서 해야함.
SELECT * 
FROM GOODS
WHERE GBRAND = '브랜드1';
--실행 순서
--데이트 조회 - SELECT  
--[5]SELECT 조회할컬러명1, 조회할컬럼명2....
--[1]FROM 테이블명
--[2]WHERE 조건
--[3]GROUP BY 그룹을 나눌 컬럼
--[4]HAVING 나눠진 그룹에 부여할 조건
--[6]ORDER BY 정렬기준컬럼

--데이터 수정 - UPDATE
--UPDATE 테이블명
--SET 컬럼명1 = 수정할 데이터, 컬럼명2 = 수정할데이터
--WHERE 데이터를 수정할 레코드를 선별할 조건
SELECT * FROM GOODS;
UPDATE GOODS
SET GPRICE = 115000, GBRAND = '브랜드명수점'
WHERE GNAME = '상품명1';

--데이터 삭제: DELETE
--DELETE FROM 테이블명
--WHERE 삭제할 레코드를 선별하는 조건

DELETE FROM GOODS
WHERE GNAME = '상품명1'; -- 1행이 삭제
DELETE FROM GOODS; --5행 전체 삭제

ROLLBACK;
SELECT * FROM GOODS;

DROP TABLE GOODS;
CREATE TABLE GOODS(
    GNAME NVARCHAR2(20) ,  --상품이름
    GPRICE NUMBER,  --상품가격
    GBRAND NVARCHAR2(20)  --상품브랜드
);
INSERT INTO GOODS(GNAME,GPRICE,GBRAND)
VALUES('상품명1',10000,'브랜드1');
INSERT INTO GOODS(GNAME,GPRICE,GBRAND)
VALUES('상품명2',15000,'브랜드1');

COMMIT; --> 커밋 데이터 저장 (세이브 파일)
ROLLBACK; --> 삭제된 데이터 롤백
SELECT * FROM GOODS; --> 확인 레코드 2개

DELETE FROM GOODS
WHERE GNAME = '상품명1'; -- 1행이 삭제
DELETE FROM GOODS; --5행 전체 삭제

INSERT INTO GOODS(GNAME,GPRICE,GBRAND)
VALUES('상품명3',15000,'브랜드1');
ROLLBACK;

CREATE TABLE TESTTBL01(COL01 NUMBER); --실행하면 자동저장. (테이블 만들면 자동 저장.)
ROLLBACK;
SELECT * FROM GOODS;
